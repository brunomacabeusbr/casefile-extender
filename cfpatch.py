#!/usr/bin/env python

tested_with = {
    'maltego': ('400b427652ca3e8ed60a6d6b7a457e81',
                'maltego-3.1.1_CE-2012-04-11.zip'),
    
    'casefile': ('8d009eae5c899d74458712fe0e1458e1',
                 'maltego-CF.1.0.1_community-2012-03-14.zip')
}

basedir_inside_zip = {
    'maltego': 'v3.0',
    'casefile': 'v3.0'
}

remove_files = [
    'maltego/modules/locale/com-paterva-maltego-ui-graph_maltego.jar'  # demo background image
]

copy_modules = [
    ('maltego-ui', 'com-paterva-maltego-transforms-standard'),
    ('maltego-ui', 'com-paterva-maltego-transform-protocol-v2'),
    ('maltego-ui', 'com-paterva-maltego-transform-manager'),
    ('maltego-ui', 'com-paterva-maltego-transform-finder'),     # needed by com-paterva-maltego-transform-manager
    ('maltego-ui', 'com-paterva-maltego-transform-discovery'),  # needed by com-paterva-maltego-transform-protocol-v2
    ('maltego-ui', 'com-paterva-maltego-transform-runner'),     # needed by com-paterva-maltego-transform-protocol-v2
    ('maltego-core-platform', 'com-paterva-maltego-typing')     # for com.paterva.maltego.typing.TypeNameValidator (needed by com-paterva-maltego-transform-manager)
]

import os
import sys
import tempfile
import shutil
import atexit
import hashlib
import zipfile
from subprocess import Popen, PIPE, STDOUT

tool_asm = os.path.realpath(os.path.join('tools', 'jasmin.jar'))
tool_disasm = os.path.realpath(os.path.join('tools', 'classfileanalyzer.jar'))
assert(os.path.exists(tool_asm) and os.path.exists(tool_disasm))


def main(maltego_zip, casefile_zip, output_zip):
    check_prerequisites()
    
    print('Starting patch...')
    
    maltego_dir, casefile_dir = [tempfile.mkdtemp() for i in range(2)]
    atexit.register(lambda *args: map(shutil.rmtree, args), maltego_dir, casefile_dir)
    
    checkmd5(maltego_zip, *tested_with['maltego'])
    checkmd5(casefile_zip, *tested_with['casefile'])
    
    unzip(maltego_zip, maltego_dir)
    unzip(casefile_zip, casefile_dir)
    
    casefile_origdir = casefile_dir
    
    maltego_dir = os.path.join(maltego_dir, basedir_inside_zip['maltego'])
    casefile_dir = os.path.join(casefile_dir, basedir_inside_zip['casefile'])
    assert(os.path.exists(maltego_dir))
    assert(os.path.exists(casefile_dir))
    
    for filename in remove_files:
        print('Removing %s' % filename)
        os.remove(os.path.join(casefile_dir, filename))
        
    for subsystem, modname in copy_modules:
        print('Copying module %s (%s) from maltego to casefile' % (modname, subsystem))
        jarpath, xmlpath = module_paths(subsystem, modname)
        shutil.copyfile(os.path.join(maltego_dir, jarpath), os.path.join(casefile_dir, jarpath))
        shutil.copyfile(os.path.join(maltego_dir, xmlpath), os.path.join(casefile_dir, xmlpath))
    
    file2jar, os.environ['CLASSPATH'] = collect_jars(casefile_dir)
    
    print('\nApplying patches inside JAR files:\n')
    
    jarpatches_dir = 'jarpatches'
    origdir = os.getcwd()
    
    patchnames = os.listdir(jarpatches_dir)
    patchnames.sort()    
    
    for patchname in patchnames:
        assert(isinstance(patchname, str))
        
        ext = patchname.rsplit('.', 2)[-1]
        if ext not in ('diff', 'jdiff', 'java'):
            print("WARNING: ignoring patch '%s' with unrecognized extension '%s'" % (patchname, ext))
            continue
        
        print('=> Applying %s' % patchname)
        
        patchfile = os.path.realpath(os.path.join(jarpatches_dir, patchname))
        jartemp = tempfile.mkdtemp()
        os.chdir(jartemp)
        
        targetfile = get_target(patchfile, ext)
        if targetfile not in file2jar:
            print("ERROR: target file '%s' not found" % targetfile)
            exit(1)
        
        jarfile = file2jar[targetfile]
        print('found in %s' % jarfile)
        jarfile = os.path.realpath(os.path.join(casefile_dir, jarfile))

        if ext != 'java':  # .java files aren't to be patched over the original files
            # extract
            p = Popen(['jar', 'xf', jarfile, targetfile], stdout=PIPE)
            p.stdout.read()
            assert(p.wait() == 0)
        
        apply_patch(patchfile, ext, targetfile)
        
        # update
        if ext == 'java':
            # update/add any files generated by javac
            p = Popen(['jar', 'uf', jarfile] + os.listdir('.'), stdout=PIPE)
        else:
            # update only the known target file
            p = Popen(['jar', 'uf', jarfile, targetfile], stdout=PIPE)
        p.stdout.read()
        assert(p.wait() == 0)
        
        os.chdir(origdir)
        shutil.rmtree(jartemp)
    
    if os.path.exists(output_zip):
        os.remove(output_zip)
    zipdir(output_zip, casefile_origdir)
    print('DONE')


def get_target(patchfile, ext):
    f = open(patchfile)
    if ext == 'diff':
        for line in f:
            assert(isinstance(line, str))
            if line.startswith('+++ '):
                return line[4:].split('\t', 2)[0]
    elif ext == 'jdiff':
        line = f.readline()
        if not line.startswith('target: '):
            print('ERROR: the first line of a jdiff file must contain the target class file')
            sys.exit(1)
        return line.split(' ', 2)[1].strip()
    elif ext == 'java':
        line = f.readline()
        if not line.startswith('//target-contains: '):
            print('ERROR: the first line of a java file must specify a file which is contained inside the target jar')
            exit(1)
        return line.split(' ', 2)[1].strip()
    f.close()


def apply_patch(patchfile, ext, targetfile):
    assert(isinstance(targetfile, str))
    if ext == 'diff':
        p = Popen(['patch', '-p0', '-i', patchfile])
        assert(p.wait() == 0)
    elif ext == 'jdiff':
        outfilename = get_target(patchfile, 'diff')
        outfile = open(outfilename, 'w')
        # disassemble
        p = Popen(['java', '-jar', tool_disasm, '-nopc', targetfile], stdout=PIPE)
        for line in p.stdout.readlines():
            outfile.write(line.decode())
        outfile.close()
        assert(p.wait() == 0)
        # patch
        apply_patch(patchfile, 'diff', outfilename)
        # reassemble
        p = Popen(['java', '-jar', tool_asm, outfilename])
        assert(p.wait() == 0)
    elif ext == 'java':
        # find original filename
        f = open(patchfile)
        f.readline()
        line = f.readline()
        f.close()
        if line.startswith('//filename: '):
            origfilename = line.split(' ', 2)[1].strip()
        else:
            origfilename = targetfile.replace('.class', '.java')
        # copy to origfilename
        os.makedirs(os.path.dirname(origfilename))
        shutil.copy(patchfile, origfilename)
        # compile
        p = Popen(['javac', '-Xlint:-options', '-source', '1.6', origfilename], env=os.environ)
        assert(p.wait() == 0)
        # remove java sourcecode
        os.remove(origfilename)


def collect_jars(basedir):
    dic = {}
    olddir = os.getcwd()
    os.chdir(basedir)
    classpath = []
    for dirname, dirs, filenames in os.walk('.'):
        for filename in filenames:
            assert(isinstance(filename, str))
            if filename.endswith('.jar'):
                filename = os.path.normpath(os.path.join(dirname, filename))
                classpath.append(os.path.realpath(filename))
                z = zipfile.ZipFile(filename, 'r')
                for ent in z.infolist():
                    if ent.external_attr & 16 == 0:  # not a directory
                        dic[ent.filename] = filename
                z.close()
    os.chdir(olddir)
    return dic, ':'.join(classpath)


def module_paths(subsystem, modname):
    jarpath = os.path.join(subsystem, 'modules', modname + '.jar')
    xmlpath = os.path.join(subsystem, 'config', 'Modules', modname + '.xml')
    return jarpath, xmlpath


def checkmd5(filename, md5hex, origfilename):
    print('Verifying MD5: %s... ' % filename, end='')
    sys.stdout.flush()
    if md5file(filename) != md5hex:
        print('failed!\n'
              '  WARNING: only tested with {}\n'
              '  (MD5: {})\n'
              '  Trying anyway...'.format(origfilename, md5hex))
    else:
        print('ok')


def md5file(filename):
    h = hashlib.md5()
    f = open(filename, 'rb')
    while True:
        data = f.read(2**20)
        if not data:
            break
        h.update(data)
    f.close()
    return h.hexdigest()


def unzip(zipfile, destdir):
    print('Unpacking %s...' % zipfile)
    p = Popen(['unzip', zipfile, '-d', destdir], stdout=PIPE)
    p.stdout.read()
    assert(p.wait() == 0)


def zipdir(zipfile, origdir):
    print('Packing %s...' % zipfile)
    zipfile = os.path.realpath(zipfile)
    p = Popen(['zip', '-r9', zipfile] + os.listdir(origdir), stdout=PIPE, cwd=origdir)
    p.stdout.read()
    assert(p.wait() == 0)


def check_prerequisites():
    for cmd in ['unzip', 'zip', 'java', 'jar', 'javac']:
        print('Checking for %s... ' % cmd, end='')
        try:
            p = Popen([cmd, '-h'], stdout=PIPE, stderr=STDOUT)
            p.stdout.read()
            p.wait()
        except OSError as e:
            if e.errno != 2:
                raise e
            print('not found\n')
            exit(1)
        print('found')


if __name__ == '__main__':
    if len(sys.argv) != 4:
        print('usage: %s maltego.zip casefile.zip output.zip\n' % sys.argv[0])
        print('takes as inputs original maltego and casefile zip files')
        print('generates a custom casefile distribution into output.zip')
        exit(1)

    main(*sys.argv[1:])
